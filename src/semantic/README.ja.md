## Semantic Analysis

### 概要

意味解析フェーズは、構文的に正しいASTに対して意味的な検証を行う。主な役割は型チェック、スコープ解決、意味的制約の検証である。

### 実装コンポーネント

#### 1. 型システム

基本的な型定義と組み込み関数の型情報を管理する。現状は以下の型をサポート：

```typescript
type Type = "void" | "int" | "string" | "bool" | "unknown";
```

組み込み関数（print等）は事前定義された型情報を持つ：

```typescript
{
  print: {
    parameters: ["string"],
    returnType: "void"
  }
}
```

#### 2. エラー処理

意味解析中のエラーを適切な位置情報と共に報告する。エラーメッセージには行番号、列番号が含まれる：

```
Semantic Error at line 1, column 10: Package must be "main"
```

#### 3. スコープ管理

スタック構造で変数や関数のスコープを管理する。以下の操作をサポート：

- スコープの追加（関数定義時等）
- スコープの削除（関数終了時等）
- スコープチェーンを通じた名前解決

#### 4. 型推論

式の種類に応じて型を決定する。現状は以下のパターンをサポート：

- リテラル: 直接対応する型を返す
- 識別子: スコープチェーンから型を解決
- 関数呼び出し: 関数定義から戻り値の型を得る

実装は直接的なマッピングに基づく。以下のような高度な型推論機能は現状含まない：

- 型の自動変換
- ジェネリクス
- 型の包含関係

#### 5. 意味的制約の検証

以下の制約を検証する：

1. パッケージ制約
   - パッケージ名は"main"のみ許可

2. 関数呼び出し制約
   - 引数の数が一致すること
   - 引数の型が期待される型と一致すること
   - 呼び出される関数が定義されていること

3. main関数の制約
   - パラメータを持たないこと
   - 明示的な戻り値型を持たないこと

### エラー検出例

現状の実装で検出可能な意味的エラー：

```go
// パッケージ名エラー
package other { print("hello") }

// 引数の型エラー
package main { print(42) }

// 引数の数エラー
package main { print() }
package main { print("a", "b") }

// main関数定義エラー
package main func main(x int) { print("hello") }
```
